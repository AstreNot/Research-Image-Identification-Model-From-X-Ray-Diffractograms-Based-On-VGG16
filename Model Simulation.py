# -*- coding: utf-8 -*-
"""Model Training.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gz_W79E1yDcxc8v4kh3TLX4Ny-6lz1PH
"""

pip install xrayutilities

from google.colab import drive
drive.mount('/content/drive')



# Commented out IPython magic to ensure Python compatibility.
import numpy
import xrayutilities as xru
from xrayutilities.materials.cif import CIFFile
from xrayutilities.materials.material import Crystal
from IPython.display import Image, display
from tempfile import NamedTemporaryFile
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from google.colab import drive, files
import pandas as pd

# %matplotlib inline
plt.rcParams.update({'font.size': 18})
fig_size = [15, 12]
plt.rcParams["figure.figsize"] = fig_size



cif = files.upload()

xu_cif = CIFFile('/content/drive/MyDrive/CIF_File/8. COD vermiculites/vermiculite p1.cif')
xu_crystal = Crystal(name="vermiculite p1", lat = xu_cif.SGLattice())
#temp_cif.close()


for s in range(1, 11, 1):
    st = s / 10
    two_theta = numpy.arange(0, 100, st)
    powder = xru.simpack.smaterials.Powder(xu_crystal, 1)
    pm = xru.simpack.PowderModel(powder, I0=100)
    intensities = pm.simulate(two_theta)
    for n in range(-10, 11, 1):
      x = two_theta + n
      plt.figure()
      plt.plot(x, intensities )
      plt.xlim(0,100, 0.01)
      plt.xlabel('2\u03B8 (degrees)')
      plt.ylabel('Intensity')
      plt.savefig("/content/drive/MyDrive/TrainingXRD/train/vermiculite p1/vermiculite p1 {}{}.png".format(s,n), bbox_inches = 'tight')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf

from tensorflow import keras
from tensorflow.keras import layers

data_train_path = '/content/drive/MyDrive/TrainingXRD/train'
data_test_path = '/content/drive/MyDrive/TrainingXRD/test'
data_val_path = '/content/drive/MyDrive/TrainingXRD/validation'

img_width = 180
img_height =180

data_train = tf.keras.utils.image_dataset_from_directory(
    data_train_path,
    shuffle=True,
    image_size=(img_width, img_height),
    batch_size=32,
    validation_split=False)

data_cat = data_train.class_names

data_cat

data_val = tf.keras.utils.image_dataset_from_directory(data_val_path,
                                                       image_size=(img_height,img_width),
                                                       batch_size=32,
                                                        shuffle=False,
                                                       validation_split=False)

data_test = tf.keras.utils.image_dataset_from_directory(
data_test_path,
    image_size=(img_height,img_width),
    shuffle=False,
    batch_size=32,
    validation_split=False
)

plt.figure(figsize=(10,10))
for image, labels in data_train.take(1):
    for i in range(9):
        plt.subplot(3,3,i+1)
        plt.imshow(image[i].numpy().astype('uint8'))
        plt.title(data_cat[labels[i]])
        plt.axis('off')

from tensorflow.keras.models import Sequential

data_train

model = Sequential([
    layers.Rescaling(1./255),
    layers.Conv2D(16, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Conv2D(32,3, padding='same',activation='relu'),
    layers.MaxPooling2D(),
    layers.Conv2D(64, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Flatten(),
    layers.Dropout(0.2),
    layers.Dense(128),
    layers.Dense(len(data_cat))

])

model.compile(optimizer='adam', loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])

epochs_size = 25
history = model.fit(data_train, validation_data=data_val, epochs=epochs_size)

epochs_range = range(epochs_size)
plt.figure(figsize=(8,8))
plt.subplot(1,2,1)
plt.plot(epochs_range,history.history['accuracy'],label = 'Training Accuracy')
plt.plot(epochs_range, history.history['val_accuracy'],label = 'Validation Accuracy')
plt.title('Accuracy')

plt.subplot(1,2,2)
plt.plot(epochs_range,history.history['loss'],label = 'Training Loss')
plt.plot(epochs_range, history.history['val_loss'],label = 'Validation Loss')
plt.title('Loss')